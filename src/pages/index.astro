---
// ## FRONTMATTER (LATO SERVER)
import Airtable from 'airtable';

const base = new Airtable({ apiKey: import.meta.env.PUBLIC_AIRTABLE_API_KEY }).base(import.meta.env.PUBLIC_AIRTABLE_BASE_ID);

type Item = { id: string; title?: string; image?: string; category?: string };

let initialItems: Item[] = [];
let initialOffset: string | null = null;
const titoloPagina = "Il mio archivio";

// Caricamento iniziale: uso top-level await con then/catch per garantire che SSR attenda il risultato
{
  const tableName = encodeURIComponent(import.meta.env.PUBLIC_AIRTABLE_TABLE_NAME);
  const baseId = import.meta.env.PUBLIC_AIRTABLE_BASE_ID;
  const viewName = encodeURIComponent('links 2');
  const url = `https://api.airtable.com/v0/${baseId}/${tableName}?pageSize=100&view=${viewName}`;
  const headers = { 'Authorization': `Bearer ${import.meta.env.PUBLIC_AIRTABLE_API_KEY}` };

  await fetch(url, { headers })
    .then(response => {
      if (!response.ok) throw new Error(`Errore dalla API di Airtable: ${response.status} ${response.statusText}`);
      return response.json();
    })
    .then((data: any) => {
      initialItems = (data.records || []).map((record: any) => ({
        id: record.id,
        title: record.fields?.['NomeImmagine'],
        image: record.fields?.immagine?.[0]?.url,
        category: record.fields?.Categoria
      }));
      initialOffset = data.offset ?? null;
    })
    .catch((err: any) => {
      console.error('ERRORE CRITICO DURANTE IL CARICAMENTO INIZIALE (FETCH):', err instanceof Error ? err.message : String(err));
    });
}
---

<html lang="it">
<head>
    <title>{titoloPagina}</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <style>
      :root {
        --max-width: 1400px;
        --gap: 1.25rem;
        --card-radius: 8px;
        --card-shadow: 0 2px 6px rgba(0,0,0,0.06);
        --thumb-aspect: 4/3;
        --title-font-size: 0.95rem;
        --title-height: 56px; /* altezza fissa area titolo */
        --bg-page: #ffffff;
        --card-bg: #ffffff;
        --title-bg: #fff;
      }

      .gallery-root {
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        max-width: var(--max-width);
        margin: 2rem auto;
        padding: 0 1rem;
        background-color: var(--bg-page);
        box-sizing: border-box;
      }

      .gallery-root .controls { margin-bottom: 1.5rem; display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
      .gallery-root .filters button { padding: 0.6rem 1.2rem; border: 1px solid #dee2e6; background-color: var(--card-bg); cursor: pointer; border-radius: 8px; }
      .gallery-root .filters button:hover { background-color: #e9ecef; }
      .gallery-root .filters button.active { background-color: #007bff; color: white; border-color: #007bff; }

      /* grid layout */
      .gallery-root .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        gap: var(--gap);
        align-items: start;
        box-sizing: border-box;
      }

      /* card */
      .gallery-root .card {
        display: flex;
        flex-direction: column;
        background-color: var(--card-bg);
        border-radius: var(--card-radius);
        box-shadow: var(--card-shadow);
        overflow: hidden;
        min-height: calc((100px) + var(--title-height)); /* evita collapsing */
      }

      /* thumb: riserva lo spazio e mantiene proporzioni */
      .gallery-root .thumb {
        width: 100%;
        aspect-ratio: var(--thumb-aspect);
        background-color: #f6f7f8;
        display: block;
        position: relative;
        overflow: hidden;
      }
      /* immagine riempie l'area e viene ritagliata in modo consistente */
      .gallery-root .thumb img {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;       /* COVER per omogeneità visiva */
        display: block;
      }

      /* area titolo: barra bianca fissa in fondo alla card */
      .gallery-root .card-content {
        padding: 0.5rem 0.75rem;
        background: var(--title-bg);
        border-top: 1px solid rgba(0,0,0,0.04);
        display: flex;
        align-items: center;
        height: var(--title-height);
        box-sizing: border-box;
      }
      .gallery-root .card-content h3 {
        margin: 0;
        font-size: var(--title-font-size);
        font-weight: 700;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* small helpers */
      #sentinel { height: 50px; }
      @media (min-width: 900px) {
        .gallery-root .grid { grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); }
        :root { --title-height: 64px; --title-font-size: 1rem; }
      }
    </style>
    <!-- Normalizza il DOM SSR: wrappa eventuali <img> lasciati fuori dalla struttura .thumb -->
    <script>
      (function normalizeSSR() {
        try {
          const cards = document.querySelectorAll('.grid .card');
          if (!cards.length) return;
          cards.forEach(card => {
            if (!card.classList.contains('card')) card.classList.add('card');

            let img = null;
            try { img = card.querySelector(':scope > img'); } catch(e) { img = null; }
            if (!img) {
              const found = Array.from(card.querySelectorAll('img')).find(i => !i.closest('.thumb'));
              img = found ?? null;
            }

            if (img && !img.closest('.thumb')) {
              const thumb = document.createElement('div');
              thumb.className = 'thumb';
              // fallback inline per .thumb quando il CSS non è ancora attivo
              thumb.style.position = 'relative';
              thumb.style.paddingTop = '75%';
              thumb.style.width = '100%';
              thumb.style.overflow = 'hidden';
              // mantiene gli angoli arrotondati in testa alla card
              thumb.style.borderTopLeftRadius = '8px';
              thumb.style.borderTopRightRadius = '8px';

              card.insertBefore(thumb, card.firstChild);
              thumb.appendChild(img);

              // se l'immagine è posizionata assoluta, applica fallback per riempire il contenitore
              img.style.position = img.style.position || 'absolute';
              img.style.top = img.style.top || '0';
              img.style.left = img.style.left || '0';
              img.style.width = img.style.width || '100%';
              img.style.height = img.style.height || '100%';
              img.style.objectFit = img.style.objectFit || 'cover';
            }

            // assicurati che la card abbia fallback di stile (in caso il CSS non sia applicato)
            card.style.borderRadius = card.style.borderRadius || '8px';
            card.style.boxShadow = card.style.boxShadow || '0 2px 6px rgba(0,0,0,0.06)';
            card.style.overflow = card.style.overflow || 'hidden';
            card.style.background = card.style.background || '#fff';
          });
        } catch (e) {
          console.warn('normalizeSSR failed', e);
        }
      })();
    </script>
</head>
<body>
    <main class="gallery-root">
        <h1>{titoloPagina}</h1>
        <p>Elementi mostrati: <span id="count">{initialItems.length}</span></p>
        <div class="controls">
            <div class="filters">
                <button class="filter-btn active" data-category="all">Tutti</button>
                <button class="filter-btn" data-category="Bandiere">Bandiere</button>
                <button class="filter-btn" data-category="Stemmi">Stemmi</button>
                <button class="filter-btn" data-category="Insigne Militari">Insigne Militari</button>
                <button class="filter-btn" data-category="Elementi per Stemmi">Elementi per Stemmi</button>
                <button class="filter-btn" data-category="Altro">Altro</button>
            </div>
        </div>
        <div class="grid" id="items-grid">
            {initialItems.map(item => (
                <article class="card">
                    {item.image && (
                      <div class="thumb">
                        <img src={item.image} alt={item.title} loading="lazy" decoding="async" />
                      </div>
                    )}
                    <div class="card-content"><h3>{item.title}</h3></div>
                </article>
            ))}
        </div>
        <div id="sentinel"></div>
        <div id="loading-indicator" style="text-align: center; padding: 2rem; display: none;">
          <p>Caricamento altri elementi...</p>
        </div>
    </main>
    <script define:vars={{ initialOffset }}>
      // Lo script client non necessita di modifiche, la sua logica è corretta.
      const grid = document.getElementById('items-grid');
      const sentinel = document.getElementById('sentinel');
      const countElement = document.getElementById('count');
      const filterButtons = document.querySelectorAll('.filter-btn');
      
      let isLoading = false;
      let allDataLoaded = false;
      let activeCategory = 'all';
      let nextOffset = initialOffset; 

      if (!nextOffset) {
        allDataLoaded = true;
        sentinel.style.display = 'none';
      }
      

      // che ogni card sia un figlio valido della griglia.
      const createCard = (item) => {
        const card = document.createElement('article');
        card.classList.add('card');

        // INLINE FALLBACK STYLES: garantiscono sempre angoli/ombra/overflow
        card.style.borderRadius = '8px';
        card.style.boxShadow = '0 2px 6px rgba(0,0,0,0.06)';
        card.style.overflow = 'hidden';
        card.style.background = '#fff';
        card.style.display = 'flex';
        card.style.flexDirection = 'column';

        if (item.image) {
          const thumb = document.createElement('div');
          thumb.classList.add('thumb');

          // fallback inline per mantenere il rapporto 4/3 se il CSS non è ancora applicato
          thumb.style.position = 'relative';
          thumb.style.paddingTop = '75%'; // 4/3 => 75%
          thumb.style.width = '100%';
          thumb.style.overflow = 'hidden';
          // arrotonda solo gli angoli superiori per evitare che l'immagine "scavalchi" il bordo
          thumb.style.borderTopLeftRadius = '8px';
          thumb.style.borderTopRightRadius = '8px';

          const img = document.createElement('img');
          img.src = item.image;
          img.alt = item.title || 'Immagine';
          img.loading = 'lazy';
          img.decoding = 'async';

          // posiziona l'immagine per riempire il contenitore
          img.style.position = 'absolute';
          img.style.top = '0';
          img.style.left = '0';
          img.style.right = '0';
          img.style.bottom = '0';
          img.style.width = '100%';
          img.style.height = '100%';
          img.style.objectFit = 'cover';
          img.style.display = 'block';

          thumb.appendChild(img);
          card.appendChild(thumb);
        }

        const contentDiv = document.createElement('div');
        contentDiv.classList.add('card-content');
        // fallback per area titolo (coerente con CSS)
        contentDiv.style.padding = '0.5rem 0.75rem';
        contentDiv.style.background = '#fff';
        contentDiv.style.borderTop = '1px solid rgba(0,0,0,0.04)';
        contentDiv.style.display = 'flex';
        contentDiv.style.alignItems = 'center';
        contentDiv.style.boxSizing = 'border-box';
        contentDiv.style.height = '56px';

        const h3 = document.createElement('h3');
        h3.textContent = item.title || '';
        h3.style.margin = '0';
        h3.style.fontSize = '0.95rem';
        h3.style.fontWeight = '700';
        h3.style.whiteSpace = 'nowrap';
        h3.style.overflow = 'hidden';
        h3.style.textOverflow = 'ellipsis';

        contentDiv.appendChild(h3);
        card.appendChild(contentDiv);
        return card;
      };

      const loadItems = async (isNewFilter = false) => {
        if (isLoading || (!isNewFilter && allDataLoaded)) return;
        isLoading = true;
        document.getElementById('loading-indicator').style.display = 'block';

        if (isNewFilter) {
          nextOffset = null; 
          allDataLoaded = false;
          grid.innerHTML = '';
        }
        
        let apiUrl = `/api/items?category=${encodeURIComponent(activeCategory)}`;
        if (nextOffset) {
          apiUrl += `&offset=${nextOffset}`;
        }

        try {
            const response = await fetch(apiUrl);
            if (!response.ok) {
                throw new Error(`Errore API: ${response.status}`);
            }
            const data = await response.json();
            const items = data.items;

            if (!data.offset) {
              allDataLoaded = true;
              sentinel.style.display = 'none';
            } else {
              sentinel.style.display = 'block';
              nextOffset = data.offset;
            }

            // meno reflow: append in batch usando DocumentFragment
            const frag = document.createDocumentFragment();
            items.forEach(item => frag.appendChild(createCard(item)));
            grid.appendChild(frag);
            countElement.textContent = grid.children.length;

        } catch (error) {
            console.error("Errore durante il caricamento degli items:", error);
            // Potremmo mostrare un messaggio di errore all'utente qui
        } finally {
            // NUOVO: Questo blocco 'finally' viene eseguito sempre,
            // sia che il caricamento abbia successo sia che fallisca.
            // È il posto perfetto per nascondere l'indicatore e sbloccare.
            isLoading = false;
            document.getElementById('loading-indicator').style.display = 'none';
        }
      };

      const observer = new IntersectionObserver(entries => {
        if (entries[0].isIntersecting && !isLoading) {
          loadItems();
        }
      });
      observer.observe(sentinel);

      filterButtons.forEach(button => {
        button.addEventListener('click', () => {
          const newCategory = button.getAttribute('data-category');
          if (newCategory === activeCategory) return;
          
          activeCategory = newCategory;
          filterButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          
          loadItems(true);
        });
      });
    </script>
  </body>
  </html>